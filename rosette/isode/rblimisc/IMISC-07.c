/* automatically generated by pepy 7.0 #14 (nanook.mcc.com), do not edit! */

#include "psap.h"

#define	advise	PY_advise

void	advise ();

/* Generated from module IMISC */

#include <stdio.h>
#include "IMISC-types.h"

#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	decode_IMISC_IA5List (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_IMISC_IA5List ** parm;
{
    register PE p4;

#ifdef DEBUG
    (void) testdebug (pe, "IMISC.IA5List");
#endif

    if (explicit) {
        if (pe -> pe_class != PE_CLASS_UNIV
                || pe -> pe_form != PE_FORM_CONS
                || pe -> pe_id != PE_CONS_SEQ) {
            advise (NULLCP, "IA5List bad class/form/id: %s/%d/0x%x",
                    pe_classlist[pe -> pe_class], pe -> pe_form, pe -> pe_id);
            return NOTOK;
        }
    }
    else
        if (pe -> pe_form != PE_FORM_CONS) {
            advise (NULLCP, "IA5List bad form: %d", pe -> pe_form);
            return NOTOK;
        }

    if ((p4 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "IA5List %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p4;

    for (p4 = first_member (pe); p4; p4 = next_member (pe, p4)) {
        {
# line 46 "IMISC-types.py"

                if ((*(parm) = (struct type_IMISC_IA5List *)
                        calloc (1, sizeof **(parm))) == ((struct type_IMISC_IA5List *) 0)) {
                    advise (NULLCP, "%s", PEPY_ERR_NOMEM);
                    return NOTOK;
                }
            
        }
        {
#ifdef DEBUG
            (void) testdebug (p4, "element");
#endif

            if (decode_UNIV_IA5String (p4, 1, NULLIP, NULLVP, &((*parm) -> IA5String)) == NOTOK)
                return NOTOK;
            {
# line 55 "IMISC-types.py"
 parm = &((*parm) -> next); 
            }
        }
    }

    return OK;
}
