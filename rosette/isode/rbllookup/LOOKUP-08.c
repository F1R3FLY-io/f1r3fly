/* automatically generated by pepy 7.0 #14 (nanook.mcc.com), do not edit! */

#include "psap.h"

#define	advise	ryr_advise

void	advise ();

/* Generated from module PasswordLookup */

#include <stdio.h>
#include "PasswordLookup-types.h"

#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	decode_PasswordLookup_GroupID (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_PasswordLookup_GroupID ** parm;
{
    register integer p16;

#ifdef DEBUG
    (void) testdebug (pe, "PasswordLookup.GroupID");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_APPL, 4)) {
        advise (NULLCP, "GroupID %s%s/0x%x", PEPY_ERR_BAD_CLASS,
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    {
# line 159 "PasswordLookup-types.py"

        if ((*(parm) = (struct type_PasswordLookup_GroupID *)
                calloc (1, sizeof **(parm))) == ((struct type_PasswordLookup_GroupID *) 0)) {
            advise (NULLCP, "%s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
    
    }
    if ((p16 = prim2num (pe)) == NOTOK
            && pe -> pe_errno != PE_ERR_NONE) {
        advise (NULLCP, "GroupID %s%s", PEPY_ERR_BAD_INTEGER,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    (*parm) -> parm  = p16;
    if (len)
        *len = p16;

    return OK;
}
