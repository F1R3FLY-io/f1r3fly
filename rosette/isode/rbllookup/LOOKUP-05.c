/* automatically generated by pepy 7.0 #14 (nanook.mcc.com), do not edit! */

#include "psap.h"

#define	advise	ryr_advise

void	advise ();

/* Generated from module PasswordLookup */

#include <stdio.h>
#include "PasswordLookup-types.h"

#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	decode_PasswordLookup_Passwd (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_PasswordLookup_Passwd ** parm;
{
    register PE p4;

#ifdef DEBUG
    (void) testdebug (pe, "PasswordLookup.Passwd");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_APPL, 1)) {
        advise (NULLCP, "Passwd %s%s/0x%x", PEPY_ERR_BAD_CLASS,
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    {
# line 84 "PasswordLookup-types.py"

        if ((*(parm) = (struct type_PasswordLookup_Passwd *)
                calloc (1, sizeof **(parm))) == ((struct type_PasswordLookup_Passwd *) 0)) {
            advise (NULLCP, "%s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
    
    }
    {
# line 93 "PasswordLookup-types.py"

                (*parm) -> quota = 0;
            
    }
    if ((p4 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "Passwd %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p4;

    {
        register PE p5;

        if ((p5 = first_member (pe)) != NULLPE) {
            p4 = p5;

            {	/* name */
#ifdef DEBUG
                (void) testdebug (p5, "name");
#endif

                if (decode_PasswordLookup_UserName (p5, 0, NULLIP, NULLVP, &((*parm) -> name)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Passwd %sname element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p6;

        if ((p6 = (pe != p4 ? next_member (pe, p4) : first_member (pe))) 
                    != NULLPE
                && PE_ID (p6 -> pe_class, p6 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 1))
            p6 = NULLPE;
        if (p6 != NULLPE) {
            p4 = p6;

            {	/* passwd */
#ifdef DEBUG
                (void) testdebug (p6, "passwd");
#endif

                if (decode_UNIV_IA5String (p6, 0, NULLIP, NULLVP, &((*parm) -> passwd)) == NOTOK)
                    return NOTOK;
            }
        }
    }

    {
        register PE p7;

        if ((p7 = (pe != p4 ? next_member (pe, p4) : first_member (pe))) != NULLPE) {
            p4 = p7;

            {	/* uid */
#ifdef DEBUG
                (void) testdebug (p7, "uid");
#endif

                if (decode_PasswordLookup_UserID (p7, 0, NULLIP, NULLVP, &((*parm) -> uid)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Passwd %suid element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p8;

        if ((p8 = (pe != p4 ? next_member (pe, p4) : first_member (pe))) != NULLPE) {
            p4 = p8;

            {	/* gid */
#ifdef DEBUG
                (void) testdebug (p8, "gid");
#endif

                if (decode_PasswordLookup_GroupID (p8, 0, NULLIP, NULLVP, &((*parm) -> gid)) == NOTOK)
                    return NOTOK;
            }
        }
        else {
            advise (NULLCP, "Passwd %sgid element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }

    {
        register PE p9;

        if ((p9 = (pe != p4 ? next_member (pe, p4) : first_member (pe))) 
                    != NULLPE
                && PE_ID (p9 -> pe_class, p9 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 4))
            p9 = NULLPE;
        if (p9 != NULLPE) {
            p4 = p9;

            {	/* quota */
                register integer p10;

#ifdef DEBUG
                (void) testdebug (p9, "quota");
#endif

                {
# line 115 "PasswordLookup-types.py"
 (*parm) -> quota = 0; 
                }
                if ((p10 = prim2num (p9)) == NOTOK
                        && p9 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "quota %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p9 -> pe_errno));
                    return NOTOK;
                }
                (*parm) -> quota  = p10;
            }
        }
        else {
            /* set default here using yp -> yp_default */
        }

    }

    {
        register PE p11;

        if ((p11 = (pe != p4 ? next_member (pe, p4) : first_member (pe))) 
                    != NULLPE
                && PE_ID (p11 -> pe_class, p11 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 5))
            p11 = NULLPE;
        if (p11 != NULLPE) {
            p4 = p11;

            {	/* comment */
#ifdef DEBUG
                (void) testdebug (p11, "comment");
#endif

                if (decode_UNIV_IA5String (p11, 0, NULLIP, NULLVP, &((*parm) -> comment)) == NOTOK)
                    return NOTOK;
            }
        }
    }

    {
        register PE p12;

        if ((p12 = (pe != p4 ? next_member (pe, p4) : first_member (pe))) 
                    != NULLPE
                && PE_ID (p12 -> pe_class, p12 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 6))
            p12 = NULLPE;
        if (p12 != NULLPE) {
            p4 = p12;

            {	/* gecos */
#ifdef DEBUG
                (void) testdebug (p12, "gecos");
#endif

                if (decode_UNIV_IA5String (p12, 0, NULLIP, NULLVP, &((*parm) -> gecos)) == NOTOK)
                    return NOTOK;
            }
        }
    }

    {
        register PE p13;

        if ((p13 = (pe != p4 ? next_member (pe, p4) : first_member (pe))) 
                    != NULLPE
                && PE_ID (p13 -> pe_class, p13 -> pe_id)
                        != PE_ID (PE_CLASS_CONT, 7))
            p13 = NULLPE;
        if (p13 != NULLPE) {
            p4 = p13;

            {	/* dir */
#ifdef DEBUG
                (void) testdebug (p13, "dir");
#endif

                if (decode_UNIV_IA5String (p13, 0, NULLIP, NULLVP, &((*parm) -> dir)) == NOTOK)
                    return NOTOK;
            }
        }
    }

    {
        register PE p14;

        if ((p14 = (pe != p4 ? next_member (pe, p4) : first_member (pe))) != NULLPE) {
            p4 = p14;

            {	/* shell */
#ifdef DEBUG
                (void) testdebug (p14, "shell");
#endif

                if (decode_UNIV_IA5String (p14, 0, NULLIP, NULLVP, &((*parm) -> shell)) == NOTOK)
                    return NOTOK;
            }
        }
    }


    if (pe -> pe_cardinal > 9) {
        advise (NULLCP, "Passwd %s(9): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}
