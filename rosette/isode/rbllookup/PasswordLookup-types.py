-- automatically generated by posy 7.0 #14 (nanook.mcc.com), do not edit!

PasswordLookup DEFINITIONS ::=

%{
#include <stdio.h>
#include "PasswordLookup-types.h"
%}

PREFIXES encode decode print

BEGIN


ENCODER encode

Passwd [[P struct type_PasswordLookup_Passwd *]] ::=
    [APPLICATION 1]
        IMPLICIT SEQUENCE
            %{
            %}
        {
            name[0]
                IMPLICIT UserName
                [[p parm -> name ]],

            passwd[1]
                IMPLICIT IA5String
                [[p parm -> passwd ]]
                OPTIONAL <<parm -> passwd>>,

            uid[2]
                IMPLICIT UserID
                [[p parm -> uid ]],

            gid[3]
                IMPLICIT GroupID
                [[p parm -> gid ]],

            quota[4]
                IMPLICIT INTEGER
                [[i parm -> quota ]]
                DEFAULT 0 <<parm -> quota != 0>>,

            comment[5]
                IMPLICIT IA5String
                [[p parm -> comment ]]
                OPTIONAL <<parm -> comment>>,

            gecos[6]
                IMPLICIT IA5String
                [[p parm -> gecos ]]
                OPTIONAL <<parm -> gecos>>,

            dir[7]
                IMPLICIT IA5String
                [[p parm -> dir ]]
                OPTIONAL <<parm -> dir>>,

            shell[8]
                IMPLICIT IA5String
                [[p parm -> shell ]]
                OPTIONAL <<parm -> shell>>
        }

UserName [[P struct type_PasswordLookup_UserName *]] ::=
    [APPLICATION 2]
        IMPLICIT GraphicString
        [[p parm ]]

UserID [[P struct type_PasswordLookup_UserID *]] ::=
    [APPLICATION 3]
        IMPLICIT INTEGER
        [[i parm -> parm ]]

GroupID [[P struct type_PasswordLookup_GroupID *]] ::=
    [APPLICATION 4]
        IMPLICIT INTEGER
        [[i parm -> parm ]]

DECODER decode

Passwd [[P struct type_PasswordLookup_Passwd **]] ::=
    %{
        if ((*(parm) = (struct type_PasswordLookup_Passwd *)
                calloc (1, sizeof **(parm))) == ((struct type_PasswordLookup_Passwd *) 0)) {
            advise (NULLCP, "%s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
    %}
    [APPLICATION 1]
        IMPLICIT SEQUENCE
            %{
                (*parm) -> quota = 0;
            %}
        {
            name[0]
                IMPLICIT UserName
                [[p &((*parm) -> name)]],

            passwd[1]
                IMPLICIT IA5String
                [[p &((*parm) -> passwd)]]
                OPTIONAL,

            uid[2]
                IMPLICIT UserID
                [[p &((*parm) -> uid)]],

            gid[3]
                IMPLICIT GroupID
                [[p &((*parm) -> gid)]],

            quota[4]
                %{ (*parm) -> quota = 0; %}
                IMPLICIT INTEGER
                [[i (*parm) -> quota ]]
                DEFAULT 0,

            comment[5]
                IMPLICIT IA5String
                [[p &((*parm) -> comment)]]
                OPTIONAL,

            gecos[6]
                IMPLICIT IA5String
                [[p &((*parm) -> gecos)]]
                OPTIONAL,

            dir[7]
                IMPLICIT IA5String
                [[p &((*parm) -> dir)]]
                OPTIONAL,

            shell[8]
                IMPLICIT IA5String
                [[p &((*parm) -> shell)]]
                OPTIONAL
        }

UserName [[P struct type_PasswordLookup_UserName **]] ::=
    [APPLICATION 2]
        IMPLICIT GraphicString
        [[p &((*parm))]]

UserID [[P struct type_PasswordLookup_UserID **]] ::=
    %{
        if ((*(parm) = (struct type_PasswordLookup_UserID *)
                calloc (1, sizeof **(parm))) == ((struct type_PasswordLookup_UserID *) 0)) {
            advise (NULLCP, "%s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
    %}
    [APPLICATION 3]
        IMPLICIT INTEGER
        [[i (*parm) -> parm ]]

GroupID [[P struct type_PasswordLookup_GroupID **]] ::=
    %{
        if ((*(parm) = (struct type_PasswordLookup_GroupID *)
                calloc (1, sizeof **(parm))) == ((struct type_PasswordLookup_GroupID *) 0)) {
            advise (NULLCP, "%s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
    %}
    [APPLICATION 4]
        IMPLICIT INTEGER
        [[i (*parm) -> parm ]]

END

%{

free_PasswordLookup_Passwd (arg)
struct type_PasswordLookup_Passwd *arg;
{
    struct type_PasswordLookup_Passwd *parm = arg;

    if (parm == NULL)
	return;

    if (parm -> name)
        free_PasswordLookup_UserName (parm -> name),
            parm -> name = NULL;
    if (parm -> passwd)
        free_UNIV_IA5String (parm -> passwd),
            parm -> passwd = NULL;
    if (parm -> uid)
        free_PasswordLookup_UserID (parm -> uid),
            parm -> uid = NULL;
    if (parm -> gid)
        free_PasswordLookup_GroupID (parm -> gid),
            parm -> gid = NULL;
    if (parm -> comment)
        free_UNIV_IA5String (parm -> comment),
            parm -> comment = NULL;
    if (parm -> gecos)
        free_UNIV_IA5String (parm -> gecos),
            parm -> gecos = NULL;
    if (parm -> dir)
        free_UNIV_IA5String (parm -> dir),
            parm -> dir = NULL;
    if (parm -> shell)
        free_UNIV_IA5String (parm -> shell),
            parm -> shell = NULL;

    free ((char *) arg);
}

free_PasswordLookup_UserID (arg)
struct type_PasswordLookup_UserID *arg;
{
    struct type_PasswordLookup_UserID *parm = arg;

    if (parm == NULL)
	return;


    free ((char *) arg);
}

free_PasswordLookup_GroupID (arg)
struct type_PasswordLookup_GroupID *arg;
{
    struct type_PasswordLookup_GroupID *parm = arg;

    if (parm == NULL)
	return;


    free ((char *) arg);
}

%}
