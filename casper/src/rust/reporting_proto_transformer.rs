// See casper/src/main/scala/coop/rchain/casper/ReportingProtoTransformer.scala

use models::casper::{
    report_proto, PeekProto, ReportCommProto, ReportConsumeProto, ReportProduceProto, ReportProto,
};
use models::rhoapi::{BindPattern, ListParWithRandom, Par, TaggedContinuation};
use rspace_plus_plus::rspace::reporting_rspace::{
    ReportingComm, ReportingConsume, ReportingProduce,
};
use rspace_plus_plus::rspace::reporting_transformer::ReportingTransformer;

pub struct ReportingProtoTransformer;

/// ARCHITECTURAL NOTE: ReportEventProto replacement
///
/// In the original Scala version, the trait returns `ReportEventProto` which is a sealed trait
/// generated by ScalaPB from the protobuf definition with the preamble annotation:
/// `preamble: "sealed trait ReportEventProto"`
///
/// However, in Rust, protobuf generators (prost) don't understand ScalaPB annotations,
/// so instead of generating a trait, they generate:
/// - `ReportProto` struct with an optional `report` field of type `report_proto::Report`
/// - `report_proto::Report` enum with variants: `Consume`, `Produce`, `Comm`
///
/// Therefore, we replaced `ReportEventProto` with `ReportProto` and wrap concrete types
/// (ReportConsumeProto, ReportProduceProto, ReportCommProto) inside the enum variants.
///
/// This maintains the same semantic meaning but uses Rust's type system instead of Scala's.

/// PERFORMANCE NOTE: Clone usage
///
/// This transformer uses .clone() extensively because:
/// 1. We transform from borrowed references (&ReportingConsume) to owned protobuf structs
/// 2. Generated protobuf types require owned data for serialization
/// 3. This is a one-time transformation for reporting, not a hot path

impl ReportingProtoTransformer {
    pub fn serialize_consume_proto(
        &self,
        rc: &ReportingConsume<Par, BindPattern, TaggedContinuation>,
    ) -> ReportConsumeProto {
        ReportConsumeProto {
            channels: rc.channels.clone(),
            patterns: rc.patterns.clone(),
            peeks: rc
                .peeks
                .iter()
                .map(|&idx| PeekProto { channel_index: idx })
                .collect(),
        }
    }

    pub fn serialize_produce_proto(
        &self,
        rp: &ReportingProduce<Par, ListParWithRandom>,
    ) -> ReportProduceProto {
        ReportProduceProto {
            channel: Some(rp.channel.clone()),
            data: Some(rp.data.clone()),
        }
    }

    pub fn serialize_comm_proto(
        &self,
        rcm: &ReportingComm<Par, BindPattern, ListParWithRandom, TaggedContinuation>,
    ) -> ReportCommProto {
        ReportCommProto {
            consume: Some(self.serialize_consume_proto(&rcm.consume)),
            produces: rcm
                .produces
                .iter()
                .map(|p| self.serialize_produce_proto(p))
                .collect(),
        }
    }
}

/// Implementation of the generic ReportingTransformer trait
///
/// This implementation mirrors the Scala architecture where ReportingProtoTransformer
/// extends ReportingTransformer[..., ReportEventProto]. In Scala, the class has:
/// 1. Concrete methods (serializeConsume/Produce/Comm) returning specific Proto types
/// 2. Trait methods that wrap these concrete types into the generic ReportEventProto
///
/// Similarly, our Rust implementation has:
/// 1. Helper methods (*_proto) that return concrete protobuf types (ReportConsumeProto, etc.)
/// 2. This trait implementation that wraps concrete types into the generic ReportProto
///
/// This dual-layer approach is NOT redundant - it precisely replicates the Scala design
/// where you can work with both concrete protobuf types and the generic event wrapper.
impl ReportingTransformer<Par, BindPattern, ListParWithRandom, TaggedContinuation, ReportProto>
    for ReportingProtoTransformer
{
    fn serialize_consume(
        &self,
        rc: &ReportingConsume<Par, BindPattern, TaggedContinuation>,
    ) -> ReportProto {
        let consume_proto = self.serialize_consume_proto(rc);
        ReportProto {
            report: Some(report_proto::Report::Consume(consume_proto)),
        }
    }

    fn serialize_produce(&self, rp: &ReportingProduce<Par, ListParWithRandom>) -> ReportProto {
        let produce_proto = self.serialize_produce_proto(rp);
        ReportProto {
            report: Some(report_proto::Report::Produce(produce_proto)),
        }
    }

    fn serialize_comm(
        &self,
        rcm: &ReportingComm<Par, BindPattern, ListParWithRandom, TaggedContinuation>,
    ) -> ReportProto {
        let comm_proto = self.serialize_comm_proto(rcm);
        ReportProto {
            report: Some(report_proto::Report::Comm(comm_proto)),
        }
    }

    // Equivalent to Scala: override def transformEvent(re: ReportingRspace.ReportingEvent): ReportEventProto = super.transformEvent(re)
    // The default implementation from ReportingTransformer trait handles this automatically
}
