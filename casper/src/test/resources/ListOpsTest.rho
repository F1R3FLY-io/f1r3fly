//scalapackage coop.rchain.rholang.collection

new
  rl(`rho:registry:lookup`), ListOpsCh, RhoSpecCh,
  greaterThan1,
  greaterThan,
  testSum,
  testForall, testForallShortcircuit,
  testExists, testExistsShortcircuit,
  testFilter,
  testPartialFoldClean,
  testForallClean, testForallCleanShortcircuit,
  testExistsClean, testExistsCleanShortcircuit,
  testFilterClean
in {
  rl!(`rho:id:zphjgsfy13h1k85isc8rtwtgt3t9zzt5pjd5ihykfmyapfc4wt3x5h`, *RhoSpecCh) |
  for(@(_, RhoSpec) <- RhoSpecCh) {
    @RhoSpec!("testSuite",
      [
        ("ListOps.sum works", *testSum),
        ("ListOps.forall works", *testForall),
        ("ListOps.forall shortcircuit", *testForallShortcircuit),
        ("ListOps.exists works", *testExists),
        ("ListOps.exists shortcircuit", *testExistsShortcircuit),
        ("ListOps.filter works", *testFilter),
        ("ListOps.partialFoldClean works", *testPartialFoldClean),
        ("ListOps.forallClean works", *testForallClean),
        ("ListOps.forallClean shortcircuit", *testForallCleanShortcircuit),
        ("ListOps.existsClean works", *testExistsClean),
        ("ListOps.existsClean shortcircuit", *testExistsCleanShortcircuit),
        ("ListOps.filterClean works", *testFilterClean),
      ])
  } |
  rl!(`rho:lang:listOps`, *ListOpsCh) |
  for(@(_, ListOps) <- ListOpsCh) {

    contract testSum(rhoSpec, _, ackCh) = {
      new ch0, ch1 in {
        @ListOps!("sum", [], *ch0) |
        @ListOps!("sum", [1, 2], *ch1) |

        rhoSpec!("assertMany",
          [
            ((0, "== <-", *ch0), "sum for empty lists is zero"),
            ((3, "== <-", *ch1), "")
          ], *ackCh)
      }
    } |

    contract testForall(rhoSpec, _, ackCh) = {
      new ch0, ch1, ch2, ch3, ch4 in {

        @ListOps!("forall", [], *greaterThan1, *ch0) |
        @ListOps!("forall", [1], *greaterThan1, *ch1) |
        @ListOps!("forall", [2], *greaterThan1, *ch2) |
        @ListOps!("forall", [3, 4], *greaterThan1, *ch3) |
        @ListOps!("forall", [1, 2, 3, 4], *greaterThan1, *ch4) |

        rhoSpec!("assertMany",
          [
            ((true, "== <-", *ch0), "forall is successful for empty lists"),
            ((false, "== <-", *ch1), "[1]"),
            ((true, "== <-", *ch2), "[2]"),
            ((true, "== <-", *ch3), "[3, 4]"),
            ((false, "== <-", *ch4), "[1, 2, 3, 4]")
          ], *ackCh)
      }
    } |

    contract testForallShortcircuit(rhoSpec, _, ackCh) = {
      new callCountCh, greaterThan1WithCount, resultCh in {
        callCountCh!(0) |
        contract greaterThan1WithCount(@x, returnCh) = {
          for (@count <- callCountCh) {
            callCountCh!(count + 1) |
            returnCh!(x > 1)
          }
        } |

        @ListOps!("forall", [2, 1, 0], *greaterThan1WithCount, *resultCh) |

        for (@result <- resultCh) {
          rhoSpec!("assertMany",
            [
              ((false, "==", result), "second item doesn't satisfy the predicate"),
              ((2, "== <-", *callCountCh), "after the first failure no more calls should happen"),
            ], *ackCh)
        }
      }
    } |

    contract testExists(rhoSpec, _, ackCh) = {
      new ch0, ch1, ch2, ch3, ch4 in {

        @ListOps!("exists", [], *greaterThan1, *ch0) |
        @ListOps!("exists", [1], *greaterThan1, *ch1) |
        @ListOps!("exists", [2], *greaterThan1, *ch2) |
        @ListOps!("exists", [3, 4], *greaterThan1, *ch3) |
        @ListOps!("exists", [1, 2, 3, 4], *greaterThan1, *ch4) |

        rhoSpec!("assertMany",
          [
            ((false, "== <-", *ch0), "exists returns false for empty lists"),
            ((false, "== <-", *ch1), "[1]"),
            ((true, "== <-", *ch2), "[2]"),
            ((true, "== <-", *ch3), "[3, 4]"),
            ((true, "== <-", *ch4), "[1, 2, 3, 4]")
          ], *ackCh)
      }
    } |

    contract testExistsShortcircuit(rhoSpec, _, ackCh) = {
      new callCountCh, greaterThan1WithCount, resultCh in {
        callCountCh!(0) |
        contract greaterThan1WithCount(@x, returnCh) = {
          for (@count <- callCountCh) {
            callCountCh!(count + 1) |
            returnCh!(x > 1)
          }
        } |

        @ListOps!("exists", [2, 1, 0], *greaterThan1WithCount, *resultCh) |

        for (@result <- resultCh) {
          rhoSpec!("assertMany",
            [
              ((true, "==", result), "first item satisfies the predicate"),
              ((1, "== <-", *callCountCh), "after the first success no more calls should happen"),
            ], *ackCh)
        }
      }
    } |

    contract testFilter(rhoSpec, _, ackCh) = {
      new ch0, ch1, ch2 in {
        @ListOps!("filter", [], *greaterThan1, *ch0) |
        @ListOps!("filter", [2, 3], *greaterThan1, *ch1) |
        @ListOps!("filter", [1, 2], *greaterThan1, *ch2) |

        rhoSpec!("assertMany",
          [
            (([], "== <-", *ch0), "filter works on empty lists"),
            (([2,3], "== <-", *ch1), "all items satisfy the predicate"),
            (([2], "== <-", *ch2), "part of the items satisfy the predicate"),
          ], *ackCh)
      }
    } |

    contract testPartialFoldClean(rhoSpec, _, ackCh) = {
      new combinatorAndCondition, ret, ret2 in {
        // Add up numbers less than state
        contract combinatorAndCondition(@state, @head, @accumulatedValue, result) = {
          if (head < state) {
            result!(false, accumulatedValue + head)
          } else {
            result!(true, accumulatedValue)
          }
        } |
        for (@_, @val <- ret2) {
          ret!(val)
        } |
        @ListOps!("partialFoldClean", [0, 1, 2, 3, 4, 5, 6], 0, *combinatorAndCondition, 5, *ret2) |
        rhoSpec!("assertMany",
          [
            ((10, "== <-", *ret), "compute partial sum correctly"),
          ], *ackCh)
      }
    } |

    contract testForallClean(rhoSpec, _, ackCh) = {
      new ch0, ch1, ch2, ch3, ch4 in {

        @ListOps!("forallClean", [], *greaterThan, 1, *ch0) |
        @ListOps!("forallClean", [1], *greaterThan, 1, *ch1) |
        @ListOps!("forallClean", [2], *greaterThan, 1, *ch2) |
        @ListOps!("forallClean", [3, 4], *greaterThan, 1, *ch3) |
        @ListOps!("forallClean", [1, 2, 3, 4], *greaterThan, 1, *ch4) |

        rhoSpec!("assertMany",
          [
            ((true, "== <-", *ch0), "forall is successful for empty lists"),
            ((false, "== <-", *ch1), "[1]"),
            ((true, "== <-", *ch2), "[2]"),
            ((true, "== <-", *ch3), "[3, 4]"),
            ((false, "== <-", *ch4), "[1, 2, 3, 4]")
          ], *ackCh)
      }
    } |

    contract testForallCleanShortcircuit(rhoSpec, _, ackCh) = {
      new callCountCh, greaterThanWithCount, resultCh in {
        callCountCh!(0) |
        contract greaterThanWithCount(@bound, @x, returnCh) = {
          for (@count <- callCountCh) {
            callCountCh!(count + 1) |
            returnCh!(x > bound)
          }
        } |

        @ListOps!("forallClean", [2, 1, 0], *greaterThanWithCount, 1, *resultCh) |

        for (@result <- resultCh) {
          rhoSpec!("assertMany",
            [
              ((false, "==", result), "second item doesn't satisfy the predicate"),
              ((2, "== <-", *callCountCh), "after the first failure no more calls should happen"),
            ], *ackCh)
        }
      }
    } |

    contract testExistsClean(rhoSpec, _, ackCh) = {
      new ch0, ch1, ch2, ch3, ch4 in {

        @ListOps!("existsClean", [], *greaterThan, 1, *ch0) |
        @ListOps!("existsClean", [1], *greaterThan, 1, *ch1) |
        @ListOps!("existsClean", [2], *greaterThan, 1, *ch2) |
        @ListOps!("existsClean", [3, 4], *greaterThan, 1, *ch3) |
        @ListOps!("existsClean", [1, 2, 3, 4], *greaterThan, 1, *ch4) |

        rhoSpec!("assertMany",
          [
            ((false, "== <-", *ch0), "exists returns false for empty lists"),
            ((false, "== <-", *ch1), "[1]"),
            ((true, "== <-", *ch2), "[2]"),
            ((true, "== <-", *ch3), "[3, 4]"),
            ((true, "== <-", *ch4), "[1, 2, 3, 4]")
          ], *ackCh)
      }
    } |

    contract testExistsCleanShortcircuit(rhoSpec, _, ackCh) = {
      new callCountCh, greaterThanWithCount, resultCh in {
        callCountCh!(0) |
        contract greaterThanWithCount(@bound, @x, returnCh) = {
          for (@count <- callCountCh) {
            callCountCh!(count + 1) |
            returnCh!(x > bound)
          }
        } |

        @ListOps!("existsClean", [2, 1, 0], *greaterThanWithCount, 1, *resultCh) |

        for (@result <- resultCh) {
          rhoSpec!("assertMany",
            [
              ((true, "==", result), "first item satisfies the predicate"),
              ((1, "== <-", *callCountCh), "after the first success no more calls should happen"),
            ], *ackCh)
        }
      }
    } |

    contract testFilterClean(rhoSpec, _, ackCh) = {
      new ch0, ch1, ch2 in {
        @ListOps!("filterClean", [], *greaterThan, 1, *ch0) |
        @ListOps!("filterClean", [2, 3], *greaterThan, 1, *ch1) |
        @ListOps!("filterClean", [1, 2], *greaterThan, 1, *ch2) |

        rhoSpec!("assertMany",
          [
            (([], "== <-", *ch0), "filter works on empty lists"),
            (([2,3], "== <-", *ch1), "all items satisfy the predicate"),
            (([2], "== <-", *ch2), "part of the items satisfy the predicate"),
          ], *ackCh)
      }
    } |

    contract greaterThan(@bound, @x, retCh) = { retCh!(x > bound) } |
    contract greaterThan1(@x, retCh) = { retCh!(x > 1) }
  }
}
