new
  rl(`rho:registry:lookup`),
  stdlog(`rho:io:stdlog`),
  lookupResult
in {
  rl!(`rho:lang:treeHashMap`, *lookupResult) |
  for (@result <- lookupResult) {
    stdlog!("info", ["Raw result:", result])
  }
}

// new
//   rl(`rho:registry:lookup`), TreeHashMapCh,
//   stdout(`rho:io:stdout`),
// 	stdlog(`rho:io:stdlog`),
//   testGetBeforeSetStdout,
// 	testGetAfterSetStdout
// in {
//   rl!(`rho:lang:treeHashMap`, *TreeHashMapCh) |
//   for(TreeHashMap <- TreeHashMapCh) {
//     contract testGetBeforeSetStdout(_) = {
//       new ret, ch in {
// 				stdlog!("TEST: Get before set returns Nil") |
//         TreeHashMap!("init", 3, *ret) |
//         for (@thm <- ret) {
// 					stdlog!("EXPECT: Getting with an unused key returns Nil") |
//           TreeHashMap!("get", thm, "no such key", *ch) |
//           for (@value <- ch) {
//             stdlog!(["ACTUAL: ", value])
//           }
//         }
//       }
//     } |

// 		contract testGetAfterSetStdout(_) = {
//       new ret, ch1, ch2 in {
//         stdlog!("TEST: Get after set returns correct values") |
//         TreeHashMap!("init", 3, *ret) |
//         for (@thm <- ret) {
//           TreeHashMap!("set", thm, "some key", "some val", *ch1) |
//           for (_ <- ch1) {
//             stdlog!("EXPECT: Getting with the proper key returns the correct value") |
//             TreeHashMap!("get", thm, "some key", *ch1) |
//             for (@value1 <- ch1) {
//               stdlog!(["ACTUAL: ", value1]) |
              
//               stdlog!("EXPECT: Getting with a different key returns Nil") |
//               TreeHashMap!("get", thm, "some other key", *ch2) |
//               for (@value2 <- ch2) {
//                 stdlog!(["ACTUAL: ", value2])
//               }
//             }
//           }
//         }
//       }
//     } |

//     testGetBeforeSetStdout!(Nil) |
// 		testGetAfterSetStdout!(Nil)
//   }
// }

// new
//   rl(`rho:registry:lookup`), TreeHashMapCh,
//   stdout(`rho:io:stdout`),
//   testGetAfterSetStdout
// in {
//   rl!(`rho:lang:treeHashMap`, *TreeHashMapCh) |
//   for(TreeHashMap <- TreeHashMapCh) {
//     contract testGetAfterSetStdout(_) = {
//       new ret, ch1, ch2 in {
//         stdout!("TEST: Get after set returns correct values") |
//         TreeHashMap!("init", 3, *ret) |
//         for (@thm <- ret) {
//           TreeHashMap!("set", thm, "some key", "some val", *ch1) |
//           for (_ <- ch1) {
//             stdout!("EXPECT: Getting with the proper key returns the correct value") |
//             TreeHashMap!("get", thm, "some key", *ch1) |
//             for (@value1 <- ch1) {
//               stdout!(["ACTUAL: ", value1]) |
              
//               stdout!("EXPECT: Getting with a different key returns Nil") |
//               TreeHashMap!("get", thm, "some other key", *ch2) |
//               for (@value2 <- ch2) {
//                 stdout!(["ACTUAL: ", value2])
//               }
//             }
//           }
//         }
//       }
//     } |

//     testGetAfterSetStdout!(Nil)
//   }
// }
