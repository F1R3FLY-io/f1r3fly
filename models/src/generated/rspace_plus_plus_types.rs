// This file is @generated by prost-build.
/// *
/// This is the first value of the tuple for the return type of the
/// Consume/Produce functions
///
/// See rspace/src/main/scala/coop/rchain/rspace/ISpace.scala
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContResultProto {
    #[prost(message, optional, tag = "1")]
    pub continuation: ::core::option::Option<super::rhoapi::TaggedContinuation>,
    #[prost(bool, tag = "2")]
    pub persistent: bool,
    #[prost(message, repeated, tag = "3")]
    pub channels: ::prost::alloc::vec::Vec<super::rhoapi::Par>,
    #[prost(message, repeated, tag = "4")]
    pub patterns: ::prost::alloc::vec::Vec<super::rhoapi::BindPattern>,
    #[prost(bool, tag = "5")]
    pub peek: bool,
}
/// *
/// This is the second value of the tuple for the return type of the
/// Consume/Produce functions
///
/// 'RSpaceResult' because Rust has a standard name type 'Result'
///
/// See rspace/src/main/scala/coop/rchain/rspace/ISpace.scala
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RSpaceResultProto {
    #[prost(message, optional, tag = "1")]
    pub channel: ::core::option::Option<super::rhoapi::Par>,
    #[prost(message, optional, tag = "2")]
    pub matched_datum: ::core::option::Option<super::rhoapi::ListParWithRandom>,
    #[prost(message, optional, tag = "3")]
    pub removed_datum: ::core::option::Option<super::rhoapi::ListParWithRandom>,
    #[prost(bool, tag = "4")]
    pub persistent: bool,
}
/// *
/// This is the tuple that is returned from the Consume/Produce functions
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionResult {
    #[prost(message, optional, tag = "1")]
    pub cont_result: ::core::option::Option<ContResultProto>,
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<RSpaceResultProto>,
}
/// *
/// Protobuf message representation of 'Datum'
/// One of the data structures returned in 'to_map' / 'toMap'
///
/// See rspace/src/main/scala/coop/rchain/rspace/internal.scala
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatumProto {
    #[prost(message, optional, tag = "1")]
    pub a: ::core::option::Option<super::rhoapi::ListParWithRandom>,
    #[prost(bool, tag = "2")]
    pub persist: bool,
    #[prost(message, optional, tag = "3")]
    pub source: ::core::option::Option<ProduceProto>,
}
/// *
/// Protobuf message representation of 'WaitingContinuation'
/// This one of the data structures returned in 'to_map' / 'toMap'
///
/// See rspace/src/main/scala/coop/rchain/rspace/internal.scala
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WaitingContinuationProto {
    #[prost(message, repeated, tag = "1")]
    pub patterns: ::prost::alloc::vec::Vec<super::rhoapi::BindPattern>,
    #[prost(message, optional, tag = "2")]
    pub continuation: ::core::option::Option<super::rhoapi::TaggedContinuation>,
    #[prost(bool, tag = "3")]
    pub persist: bool,
    #[prost(message, repeated, tag = "4")]
    pub peeks: ::prost::alloc::vec::Vec<SortedSetElement>,
    #[prost(message, optional, tag = "5")]
    pub source: ::core::option::Option<ConsumeProto>,
}
/// *
/// This message is needed on the Scala side because the
/// 'project/StacksafeScalapbGenerator.scala' file prohibits packable fields
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SortedSetElement {
    #[prost(int32, tag = "1")]
    pub value: i32,
}
/// *
/// Protobuf message representation of 'Produce'
///
/// See rspace/src/main/scala/coop/rchain/rspace/trace/Event.scala
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProduceProto {
    #[prost(bytes = "vec", tag = "1")]
    pub channel_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "3")]
    pub persistent: bool,
}
/// *
/// Protobuf message representation of 'Consume'
///
/// See rspace/src/main/scala/coop/rchain/rspace/trace/Event.scala
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumeProto {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub channel_hashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", tag = "2")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "3")]
    pub persistent: bool,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreToMapValue {
    #[prost(message, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<DatumProto>,
    #[prost(message, repeated, tag = "2")]
    pub wks: ::prost::alloc::vec::Vec<WaitingContinuationProto>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreToMapEntry {
    #[prost(message, repeated, tag = "1")]
    pub key: ::prost::alloc::vec::Vec<super::rhoapi::Par>,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<StoreToMapValue>,
}
/// *
/// Return type for 'to_map' / 'toMap'
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreToMapResult {
    #[prost(message, repeated, tag = "1")]
    pub map_entries: ::prost::alloc::vec::Vec<StoreToMapEntry>,
}
/// *
/// Data structure for 'consume' function parameters
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumeParams {
    #[prost(message, repeated, tag = "1")]
    pub channels: ::prost::alloc::vec::Vec<super::rhoapi::Par>,
    #[prost(message, repeated, tag = "2")]
    pub patterns: ::prost::alloc::vec::Vec<super::rhoapi::BindPattern>,
    #[prost(message, optional, tag = "3")]
    pub continuation: ::core::option::Option<super::rhoapi::TaggedContinuation>,
    #[prost(bool, tag = "4")]
    pub persist: bool,
    #[prost(message, repeated, tag = "5")]
    pub peeks: ::prost::alloc::vec::Vec<SortedSetElement>,
}
/// *
/// Data structure for 'install' function parameters
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallParams {
    #[prost(message, repeated, tag = "1")]
    pub channels: ::prost::alloc::vec::Vec<super::rhoapi::Par>,
    #[prost(message, repeated, tag = "2")]
    pub patterns: ::prost::alloc::vec::Vec<super::rhoapi::BindPattern>,
    #[prost(message, optional, tag = "3")]
    pub continuation: ::core::option::Option<super::rhoapi::TaggedContinuation>,
}
/// *
/// Data structure for 'spatial_match_result' function return type
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FreeMapProto {
    #[prost(btree_map = "int32, message", tag = "1")]
    pub entries: ::prost::alloc::collections::BTreeMap<i32, super::rhoapi::Par>,
}
/// *
/// Protobuf message representation of 'Checkpoint'
///
/// See rspace/src/main/scala/coop/rchain/rspace/Checkpoint.scala
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointProto {
    #[prost(bytes = "vec", tag = "1")]
    pub root: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "2")]
    pub log: ::prost::alloc::vec::Vec<EventProto>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelsProto {
    #[prost(message, repeated, tag = "1")]
    pub channels: ::prost::alloc::vec::Vec<super::rhoapi::Par>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatumsProto {
    #[prost(message, repeated, tag = "1")]
    pub datums: ::prost::alloc::vec::Vec<DatumProto>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WaitingContinuationsProto {
    #[prost(message, repeated, tag = "1")]
    pub wks: ::prost::alloc::vec::Vec<WaitingContinuationProto>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinProto {
    #[prost(message, repeated, tag = "1")]
    pub join: ::prost::alloc::vec::Vec<super::rhoapi::Par>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinsProto {
    #[prost(message, repeated, tag = "1")]
    pub joins: ::prost::alloc::vec::Vec<JoinProto>,
}
/// *
/// Protobuf message representation of 'HotStoreState'
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HotStoreStateProto {
    #[prost(message, repeated, tag = "1")]
    pub continuations: ::prost::alloc::vec::Vec<StoreStateContMapEntry>,
    #[prost(message, repeated, tag = "2")]
    pub installed_continuations: ::prost::alloc::vec::Vec<
        StoreStateInstalledContMapEntry,
    >,
    #[prost(message, repeated, tag = "3")]
    pub data: ::prost::alloc::vec::Vec<StoreStateDataMapEntry>,
    #[prost(message, repeated, tag = "4")]
    pub joins: ::prost::alloc::vec::Vec<StoreStateJoinsMapEntry>,
    #[prost(message, repeated, tag = "5")]
    pub installed_joins: ::prost::alloc::vec::Vec<StoreStateInstalledJoinsMapEntry>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreStateContMapEntry {
    #[prost(message, repeated, tag = "1")]
    pub key: ::prost::alloc::vec::Vec<super::rhoapi::Par>,
    #[prost(message, repeated, tag = "2")]
    pub value: ::prost::alloc::vec::Vec<WaitingContinuationProto>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreStateInstalledContMapEntry {
    #[prost(message, repeated, tag = "1")]
    pub key: ::prost::alloc::vec::Vec<super::rhoapi::Par>,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<WaitingContinuationProto>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreStateDataMapEntry {
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<super::rhoapi::Par>,
    #[prost(message, repeated, tag = "2")]
    pub value: ::prost::alloc::vec::Vec<DatumProto>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreStateJoinsMapEntry {
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<super::rhoapi::Par>,
    #[prost(message, repeated, tag = "2")]
    pub value: ::prost::alloc::vec::Vec<JoinProto>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreStateInstalledJoinsMapEntry {
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<super::rhoapi::Par>,
    #[prost(message, repeated, tag = "2")]
    pub value: ::prost::alloc::vec::Vec<JoinProto>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProduceCounterMapEntry {
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<ProduceProto>,
    #[prost(int32, tag = "2")]
    pub value: i32,
}
/// *
/// Protobuf message representation of 'SoftCheckpoint'
///
/// See rspace/src/main/scala/coop/rchain/rspace/Checkpoint.scala
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SoftCheckpointProto {
    #[prost(message, optional, tag = "1")]
    pub cache_snapshot: ::core::option::Option<HotStoreStateProto>,
    #[prost(message, repeated, tag = "2")]
    pub log: ::prost::alloc::vec::Vec<EventProto>,
    #[prost(message, repeated, tag = "3")]
    pub produce_counter: ::prost::alloc::vec::Vec<ProduceCounterMapEntry>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IoEventProto {
    #[prost(oneof = "io_event_proto::IoEventType", tags = "1, 2")]
    pub io_event_type: ::core::option::Option<io_event_proto::IoEventType>,
}
/// Nested message and enum types in `IOEventProto`.
pub mod io_event_proto {
    #[derive(serde::Serialize, serde::Deserialize, std::cmp::Eq, Hash, Ord, PartialOrd)]
    #[repr(C)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum IoEventType {
        #[prost(message, tag = "1")]
        Produce(super::ProduceProto),
        #[prost(message, tag = "2")]
        Consume(super::ConsumeProto),
    }
}
/// Define the Event message with a oneof field
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventProto {
    #[prost(oneof = "event_proto::EventType", tags = "1, 2")]
    pub event_type: ::core::option::Option<event_proto::EventType>,
}
/// Nested message and enum types in `EventProto`.
pub mod event_proto {
    #[derive(serde::Serialize, serde::Deserialize, std::cmp::Eq, Hash, Ord, PartialOrd)]
    #[repr(C)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EventType {
        #[prost(message, tag = "1")]
        Comm(super::CommProto),
        #[prost(message, tag = "2")]
        IoEvent(super::IoEventProto),
    }
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommProto {
    #[prost(message, optional, tag = "1")]
    pub consume: ::core::option::Option<ConsumeProto>,
    #[prost(message, repeated, tag = "2")]
    pub produces: ::prost::alloc::vec::Vec<ProduceProto>,
    #[prost(message, repeated, tag = "3")]
    pub peeks: ::prost::alloc::vec::Vec<SortedSetElement>,
    #[prost(message, repeated, tag = "4")]
    pub times_repeated: ::prost::alloc::vec::Vec<ProduceCounterMapEntry>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogProto {
    #[prost(message, repeated, tag = "1")]
    pub log: ::prost::alloc::vec::Vec<EventProto>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HashProto {
    #[prost(bytes = "vec", tag = "1")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ItemProto {
    #[prost(bytes = "vec", tag = "1")]
    pub key_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ItemsProto {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<ItemProto>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ByteVectorProto {
    #[prost(bytes = "vec", tag = "1")]
    pub byte_vector: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PathElement {
    #[prost(bytes = "vec", tag = "1")]
    pub key_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub optional_byte: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExporterParams {
    #[prost(message, repeated, tag = "1")]
    pub path: ::prost::alloc::vec::Vec<PathElement>,
    #[prost(int32, tag = "2")]
    pub skip: i32,
    #[prost(int32, tag = "3")]
    pub take: i32,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrieNodeProto {
    #[prost(bytes = "vec", tag = "1")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "2")]
    pub is_leaf: bool,
    #[prost(message, repeated, tag = "3")]
    pub path: ::prost::alloc::vec::Vec<PathElement>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrieNodesProto {
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<TrieNodeProto>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeysProto {
    #[prost(message, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<HashProto>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreItemsProto {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<ItemProto>,
    #[prost(message, repeated, tag = "2")]
    pub last_path: ::prost::alloc::vec::Vec<PathElement>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistoryAndDataItems {
    #[prost(message, optional, tag = "1")]
    pub history_items: ::core::option::Option<StoreItemsProto>,
    #[prost(message, optional, tag = "2")]
    pub data_items: ::core::option::Option<StoreItemsProto>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateStateParams {
    #[prost(message, repeated, tag = "1")]
    pub history_items: ::prost::alloc::vec::Vec<ItemProto>,
    #[prost(message, repeated, tag = "2")]
    pub data_items: ::prost::alloc::vec::Vec<ItemProto>,
    #[prost(message, repeated, tag = "3")]
    pub start_path: ::prost::alloc::vec::Vec<PathElement>,
    #[prost(int32, tag = "4")]
    pub chunk_size: i32,
    #[prost(int32, tag = "5")]
    pub skip: i32,
}
