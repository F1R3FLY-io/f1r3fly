// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScalaPbOptions {
    /// If set then it overrides the java_package and package.
    #[prost(string, optional, tag = "1")]
    pub package_name: ::core::option::Option<::prost::alloc::string::String>,
    /// If true, the compiler does not append the proto base file name
    /// into the generated package name. If false (the default), the
    /// generated scala package name is the package_name.basename where
    /// basename is the proto file name without the .proto extension.
    #[prost(bool, optional, tag = "2")]
    pub flat_package: ::core::option::Option<bool>,
    /// Adds the following imports at the top of the file (this is meant
    /// to provide implicit TypeMappers)
    #[prost(string, repeated, tag = "3")]
    pub import: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Text to add to the generated scala file.  This can be used only
    /// when single_file is true.
    #[prost(string, repeated, tag = "4")]
    pub preamble: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If true, all messages and enums (but not services) will be written
    /// to a single Scala file.
    #[prost(bool, optional, tag = "5")]
    pub single_file: ::core::option::Option<bool>,
    /// By default, wrappers defined at
    /// <https://github.com/google/protobuf/blob/master/src/google/protobuf/wrappers.proto,>
    /// are mapped to an Option\[T\] where T is a primitive type. When this field
    /// is set to true, we do not perform this transformation.
    #[prost(bool, optional, tag = "7")]
    pub no_primitive_wrappers: ::core::option::Option<bool>,
    /// DEPRECATED. In ScalaPB <= 0.5.47, it was necessary to explicitly enable
    /// primitive_wrappers. This field remains here for backwards compatibility,
    /// but it has no effect on generated code. It is an error to set both
    /// `primitive_wrappers` and `no_primitive_wrappers`.
    #[prost(bool, optional, tag = "6")]
    pub primitive_wrappers: ::core::option::Option<bool>,
    /// Scala type to be used for repeated fields. If unspecified,
    /// `scala.collection.Seq` will be used.
    #[prost(string, optional, tag = "8")]
    pub collection_type: ::core::option::Option<::prost::alloc::string::String>,
    /// If set to true, all generated messages in this file will preserve unknown
    /// fields.
    #[prost(bool, optional, tag = "9", default = "true")]
    pub preserve_unknown_fields: ::core::option::Option<bool>,
    /// If defined, sets the name of the file-level object that would be generated. This
    /// object extends `GeneratedFileObject` and contains descriptors, and list of message
    /// and enum companions.
    #[prost(string, optional, tag = "10")]
    pub object_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Experimental: scope to apply the given options.
    #[prost(enumeration = "scala_pb_options::OptionsScope", optional, tag = "11")]
    pub scope: ::core::option::Option<i32>,
    /// If true, lenses will be generated.
    #[prost(bool, optional, tag = "12", default = "true")]
    pub lenses: ::core::option::Option<bool>,
    /// If true, then source-code info information will be included in the
    /// generated code - normally the source code info is cleared out to reduce
    /// code size.  The source code info is useful for extracting source code
    /// location from the descriptors as well as comments.
    #[prost(bool, optional, tag = "13")]
    pub retain_source_code_info: ::core::option::Option<bool>,
    /// Scala type to be used for maps. If unspecified,
    /// `scala.collection.immutable.Map` will be used.
    #[prost(string, optional, tag = "14")]
    pub map_type: ::core::option::Option<::prost::alloc::string::String>,
    /// If true, no default values will be generated in message constructors.
    /// This setting can be overridden at the message-level and for individual
    /// fields.
    #[prost(bool, optional, tag = "15")]
    pub no_default_values_in_constructor: ::core::option::Option<bool>,
    #[prost(enumeration = "scala_pb_options::EnumValueNaming", optional, tag = "16")]
    pub enum_value_naming: ::core::option::Option<i32>,
    /// Indicate if prefix (enum name + optional underscore) should be removed in scala code
    /// Strip is applied before enum value naming changes.
    #[prost(bool, optional, tag = "17", default = "false")]
    pub enum_strip_prefix: ::core::option::Option<bool>,
    /// Scala type to use for bytes fields.
    #[prost(string, optional, tag = "21")]
    pub bytes_type: ::core::option::Option<::prost::alloc::string::String>,
    /// Enable java conversions for this file.
    #[prost(bool, optional, tag = "23")]
    pub java_conversions: ::core::option::Option<bool>,
    /// List of message options to apply to some messages.
    #[prost(message, repeated, tag = "18")]
    pub aux_message_options: ::prost::alloc::vec::Vec<
        scala_pb_options::AuxMessageOptions,
    >,
    /// List of message options to apply to some fields.
    #[prost(message, repeated, tag = "19")]
    pub aux_field_options: ::prost::alloc::vec::Vec<scala_pb_options::AuxFieldOptions>,
    /// List of message options to apply to some enums.
    #[prost(message, repeated, tag = "20")]
    pub aux_enum_options: ::prost::alloc::vec::Vec<scala_pb_options::AuxEnumOptions>,
    /// List of enum value options to apply to some enum values.
    #[prost(message, repeated, tag = "22")]
    pub aux_enum_value_options: ::prost::alloc::vec::Vec<
        scala_pb_options::AuxEnumValueOptions,
    >,
    /// List of preprocessors to apply.
    #[prost(string, repeated, tag = "24")]
    pub preprocessors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "25")]
    pub field_transformations: ::prost::alloc::vec::Vec<FieldTransformation>,
    /// Ignores all transformations for this file. This is meant to allow specific files to
    /// opt out from transformations inherited through package-scoped options.
    #[prost(bool, optional, tag = "26")]
    pub ignore_all_transformations: ::core::option::Option<bool>,
    /// If true, getters will be generated.
    #[prost(bool, optional, tag = "27", default = "true")]
    pub getters: ::core::option::Option<bool>,
    /// Generate sources that are compatible with Scala 3
    #[prost(bool, optional, tag = "28")]
    pub scala3_sources: ::core::option::Option<bool>,
    /// Makes constructor parameters public, including defaults and TypeMappers.
    #[prost(bool, optional, tag = "29")]
    pub public_constructor_parameters: ::core::option::Option<bool>,
    /// For use in tests only. Inhibit Java conversions even when when generator parameters
    /// request for it.
    #[prost(bool, optional, tag = "999")]
    pub test_only_no_java_conversions: ::core::option::Option<bool>,
}
/// Nested message and enum types in `ScalaPbOptions`.
pub mod scala_pb_options {
    /// AuxMessageOptions enables you to set message-level options through package-scoped options.
    /// This is useful when you can't add a dependency on scalapb.proto from the proto file that
    /// defines the message.
    #[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
    #[repr(C)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AuxMessageOptions {
        /// The fully-qualified name of the message in the proto name space. Set to `*` to apply to all
        /// messages in scope.
        #[prost(string, optional, tag = "1")]
        pub target: ::core::option::Option<::prost::alloc::string::String>,
        /// Options to apply to the message. If there are any options defined on the target message
        /// they take precedence over the options.
        #[prost(message, optional, tag = "2")]
        pub options: ::core::option::Option<super::MessageOptions>,
    }
    /// AuxFieldOptions enables you to set field-level options through package-scoped options.
    /// This is useful when you can't add a dependency on scalapb.proto from the proto file that
    /// defines the field.
    #[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
    #[repr(C)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AuxFieldOptions {
        /// The fully-qualified name of the field in the proto name space. Set to `*` to apply to all
        /// fields in scope.
        #[prost(string, optional, tag = "1")]
        pub target: ::core::option::Option<::prost::alloc::string::String>,
        /// Options to apply to the field. If there are any options defined on the target message
        /// they take precedence over the options.
        #[prost(message, optional, tag = "2")]
        pub options: ::core::option::Option<super::FieldOptions>,
    }
    /// AuxEnumOptions enables you to set enum-level options through package-scoped options.
    /// This is useful when you can't add a dependency on scalapb.proto from the proto file that
    /// defines the enum.
    #[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
    #[repr(C)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AuxEnumOptions {
        /// The fully-qualified name of the enum in the proto name space. Set to `*` to apply to
        /// all enums in scope.
        #[prost(string, optional, tag = "1")]
        pub target: ::core::option::Option<::prost::alloc::string::String>,
        /// Options to apply to the enum. If there are any options defined on the target enum
        /// they take precedence over the options.
        #[prost(message, optional, tag = "2")]
        pub options: ::core::option::Option<super::EnumOptions>,
    }
    /// AuxEnumValueOptions enables you to set enum value level options through package-scoped
    /// options.  This is useful when you can't add a dependency on scalapb.proto from the proto
    /// file that defines the enum.
    #[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
    #[repr(C)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AuxEnumValueOptions {
        /// The fully-qualified name of the enum value in the proto name space. Set to `*` to apply
        /// to all enum values in scope.
        #[prost(string, optional, tag = "1")]
        pub target: ::core::option::Option<::prost::alloc::string::String>,
        /// Options to apply to the enum value. If there are any options defined on
        /// the target enum value they take precedence over the options.
        #[prost(message, optional, tag = "2")]
        pub options: ::core::option::Option<super::EnumValueOptions>,
    }
    /// Whether to apply the options only to this file, or for the entire package (and its subpackages)
    #[derive(serde::Serialize, serde::Deserialize, std::cmp::Eq, Hash, Ord, PartialOrd)]
    #[repr(C)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OptionsScope {
        /// Apply the options for this file only (default)
        File = 0,
        /// Apply the options for the entire package and its subpackages.
        Package = 1,
    }
    impl OptionsScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OptionsScope::File => "FILE",
                OptionsScope::Package => "PACKAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FILE" => Some(Self::File),
                "PACKAGE" => Some(Self::Package),
                _ => None,
            }
        }
    }
    /// Naming convention for generated enum values
    #[derive(serde::Serialize, serde::Deserialize, std::cmp::Eq, Hash, Ord, PartialOrd)]
    #[repr(C)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnumValueNaming {
        /// Enum value names in Scala use the same name as in the proto
        AsInProto = 0,
        /// Convert enum values to CamelCase in Scala.
        CamelCase = 1,
    }
    impl EnumValueNaming {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EnumValueNaming::AsInProto => "AS_IN_PROTO",
                EnumValueNaming::CamelCase => "CAMEL_CASE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AS_IN_PROTO" => Some(Self::AsInProto),
                "CAMEL_CASE" => Some(Self::CamelCase),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageOptions {
    /// Additional classes and traits to mix in to the case class.
    #[prost(string, repeated, tag = "1")]
    pub extends: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Additional classes and traits to mix in to the companion object.
    #[prost(string, repeated, tag = "2")]
    pub companion_extends: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Custom annotations to add to the generated case class.
    #[prost(string, repeated, tag = "3")]
    pub annotations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// All instances of this message will be converted to this type. An implicit TypeMapper
    /// must be present.
    #[prost(string, optional, tag = "4")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    /// Custom annotations to add to the companion object of the generated class.
    #[prost(string, repeated, tag = "5")]
    pub companion_annotations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Additional classes and traits to mix in to generated sealed_oneof base trait.
    #[prost(string, repeated, tag = "6")]
    pub sealed_oneof_extends: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If true, when this message is used as an optional field, do not wrap it in an `Option`.
    /// This is equivalent of setting `(field).no_box` to true on each field with the message type.
    #[prost(bool, optional, tag = "7")]
    pub no_box: ::core::option::Option<bool>,
    /// Custom annotations to add to the generated `unknownFields` case class field.
    #[prost(string, repeated, tag = "8")]
    pub unknown_fields_annotations: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// If true, no default values will be generated in message constructors.
    /// If set (to true or false), the message-level setting overrides the
    /// file-level value, and can be overridden by the field-level setting.
    #[prost(bool, optional, tag = "9")]
    pub no_default_values_in_constructor: ::core::option::Option<bool>,
    /// Additional classes and traits to mix in to generated sealed oneof base trait's companion object.
    #[prost(string, repeated, tag = "10")]
    pub sealed_oneof_companion_extends: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Adds a derives clause to the message case class
    #[prost(string, repeated, tag = "11")]
    pub derives: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Additional classes and traits to add to the derives clause of a sealed oneof.
    #[prost(string, repeated, tag = "12")]
    pub sealed_oneof_derives: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Additional traits to mixin for the empty case object of sealed oneofs.
    #[prost(string, repeated, tag = "13")]
    pub sealed_oneof_empty_extends: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Represents a custom Collection type in Scala. This allows ScalaPB to integrate with
/// collection types that are different enough from the ones in the standard library.
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Collection {
    /// Type of the collection
    #[prost(string, optional, tag = "1")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    /// Set to true if this collection type is not allowed to be empty, for example
    /// cats.data.NonEmptyList.  When true, ScalaPB will not generate `clearX` for the repeated
    /// field and not provide a default argument in the constructor.
    #[prost(bool, optional, tag = "2")]
    pub non_empty: ::core::option::Option<bool>,
    /// An Adapter is a Scala object available at runtime that provides certain static methods
    /// that can operate on this collection type.
    #[prost(string, optional, tag = "3")]
    pub adapter: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldOptions {
    #[prost(string, optional, tag = "1")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub scala_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Can be specified only if this field is repeated. If unspecified,
    /// it falls back to the file option named `collection_type`, which defaults
    /// to `scala.collection.Seq`.
    #[prost(string, optional, tag = "3")]
    pub collection_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "8")]
    pub collection: ::core::option::Option<Collection>,
    /// If the field is a map, you can specify custom Scala types for the key
    /// or value.
    #[prost(string, optional, tag = "4")]
    pub key_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub value_type: ::core::option::Option<::prost::alloc::string::String>,
    /// Custom annotations to add to the field.
    #[prost(string, repeated, tag = "6")]
    pub annotations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Can be specified only if this field is a map. If unspecified,
    /// it falls back to the file option named `map_type` which defaults to
    /// `scala.collection.immutable.Map`
    #[prost(string, optional, tag = "7")]
    pub map_type: ::core::option::Option<::prost::alloc::string::String>,
    /// If true, no default value will be generated for this field in the message
    /// constructor. If this field is set, it has the highest precedence and overrides the
    /// values at the message-level and file-level.
    #[prost(bool, optional, tag = "9")]
    pub no_default_value_in_constructor: ::core::option::Option<bool>,
    /// Do not box this value in Option\[T\]. If set, this overrides MessageOptions.no_box
    #[prost(bool, optional, tag = "30")]
    pub no_box: ::core::option::Option<bool>,
    /// Like no_box it does not box a value in Option\[T\], but also fails parsing when a value
    /// is not provided. This enables to emulate required fields in proto3.
    #[prost(bool, optional, tag = "31")]
    pub required: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumOptions {
    /// Additional classes and traits to mix in to the base trait
    #[prost(string, repeated, tag = "1")]
    pub extends: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Additional classes and traits to mix in to the companion object.
    #[prost(string, repeated, tag = "2")]
    pub companion_extends: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// All instances of this enum will be converted to this type. An implicit TypeMapper
    /// must be present.
    #[prost(string, optional, tag = "3")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    /// Custom annotations to add to the generated enum's base class.
    #[prost(string, repeated, tag = "4")]
    pub base_annotations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Custom annotations to add to the generated trait.
    #[prost(string, repeated, tag = "5")]
    pub recognized_annotations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Custom annotations to add to the generated Unrecognized case class.
    #[prost(string, repeated, tag = "6")]
    pub unrecognized_annotations: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumValueOptions {
    /// Additional classes and traits to mix in to an individual enum value.
    #[prost(string, repeated, tag = "1")]
    pub extends: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Name in Scala to use for this enum value.
    #[prost(string, optional, tag = "2")]
    pub scala_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Custom annotations to add to the generated case object for this enum value.
    #[prost(string, repeated, tag = "3")]
    pub annotations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OneofOptions {
    /// Additional traits to mix in to a oneof.
    #[prost(string, repeated, tag = "1")]
    pub extends: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Name in Scala to use for this oneof field.
    #[prost(string, optional, tag = "2")]
    pub scala_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldTransformation {
    #[prost(message, optional, tag = "1")]
    pub when: ::core::option::Option<::prost_types::FieldDescriptorProto>,
    #[prost(enumeration = "MatchType", optional, tag = "2", default = "Contains")]
    pub match_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub set: ::core::option::Option<::prost_types::FieldOptions>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreprocessorOutput {
    #[prost(btree_map = "string, message", tag = "1")]
    pub options_by_file: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ScalaPbOptions,
    >,
}
#[derive(serde::Serialize, serde::Deserialize, std::cmp::Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MatchType {
    Contains = 0,
    Exact = 1,
    Presence = 2,
}
impl MatchType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MatchType::Contains => "CONTAINS",
            MatchType::Exact => "EXACT",
            MatchType::Presence => "PRESENCE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONTAINS" => Some(Self::Contains),
            "EXACT" => Some(Self::Exact),
            "PRESENCE" => Some(Self::Presence),
            _ => None,
        }
    }
}
