// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRuntimeParams {
    #[prost(message, optional, tag = "1")]
    pub mergeable_tag_name: ::core::option::Option<super::rhoapi::Par>,
    #[prost(bool, tag = "2")]
    pub init_registry: bool,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockDataProto {
    #[prost(int64, tag = "1")]
    pub time_stamp: i64,
    #[prost(int64, tag = "2")]
    pub block_number: i64,
    #[prost(bytes = "vec", tag = "3")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(int32, tag = "4")]
    pub seq_num: i32,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluateParams {
    #[prost(string, tag = "1")]
    pub term: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub initial_phlo: ::core::option::Option<CostProto>,
    #[prost(btree_map = "string, message", tag = "3")]
    pub normalizer_env: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        super::rhoapi::Par,
    >,
    #[prost(message, optional, tag = "4")]
    pub random_state: ::core::option::Option<Blake2b512RandomProto>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CostProto {
    #[prost(int64, tag = "1")]
    pub value: i64,
    #[prost(string, tag = "2")]
    pub operation: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Blake2b512RandomProto {
    #[prost(message, optional, tag = "1")]
    pub digest: ::core::option::Option<Blake2b512BlockProto>,
    #[prost(bytes = "vec", tag = "2")]
    pub last_block: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub path_view: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "4")]
    pub count_view: ::prost::alloc::vec::Vec<UInt64Proto>,
    #[prost(bytes = "vec", tag = "5")]
    pub hash_array: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "6")]
    pub position: i64,
    #[prost(int32, tag = "7")]
    pub path_position: i32,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Blake2b512BlockProto {
    #[prost(message, repeated, tag = "1")]
    pub chain_value: ::prost::alloc::vec::Vec<Int64Proto>,
    #[prost(int64, tag = "2")]
    pub t0: i64,
    #[prost(int64, tag = "3")]
    pub t1: i64,
}
/// This is needed because repeated primitive types (packable) are not supported
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Int64Proto {
    #[prost(int64, tag = "1")]
    pub value: i64,
}
/// This is needed because repeated primitive types (packable) are not supported
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UInt64Proto {
    #[prost(uint64, tag = "1")]
    pub value: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluateResultProto {
    #[prost(message, optional, tag = "1")]
    pub cost: ::core::option::Option<CostProto>,
    #[prost(string, repeated, tag = "2")]
    pub errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub mergeable: ::prost::alloc::vec::Vec<super::rhoapi::Par>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHashValidator {
    #[prost(bytes = "vec", tag = "1")]
    pub block_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub validator: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvalidBlocksProto {
    #[prost(message, repeated, tag = "1")]
    pub invalid_blocks: ::prost::alloc::vec::Vec<BlockHashValidator>,
}
